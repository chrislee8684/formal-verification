MODULE main

VAR
  -- Market
  Mid : 0..200;

  -- Quotes
  Bid : 0..200;
  Ask : 0..200;

  -- Inventory
  Inv : -10000..10000;

  -- Bid order state
  Bid_state : {NONE, ACTIVE, CANCEL_SENT, FILLED, CANCELED};

  -- Signals
  Market_data  : boolean;
  Quote_posted : boolean;

  -- Liveness obligations
  Pending_quote  : boolean;
  Pending_cancel : boolean;

DEFINE
  -- Checks if we can post a quote (used to fix quote cancellation issues)
  Can_post_quote := Market_data & !(Bid_state = CANCEL_SENT);

ASSIGN
  -- Initial state
  init(Mid) := 100;
  init(Bid) := 99;
  init(Ask) := 101;
  init(Inv) := 0;

  init(Bid_state) := NONE;

  init(Market_data) := FALSE;
  init(Quote_posted) := FALSE;

  init(Pending_quote) := FALSE;
  init(Pending_cancel) := FALSE;

  -- Mid evolution
  next(Mid) := case
    Mid = 0   : {0, 1};
    Mid = 200 : {199, 200};
    TRUE      : {Mid - 1, Mid, Mid + 1};
  esac;

  -- Market data arrives
  next(Market_data) := case
    Quote_posted : FALSE;           -- posting consumes data
    Market_data  : TRUE;            -- latch: once true, stays true until consumed
    TRUE         : {TRUE, FALSE};   -- new data may arrive
  esac;

  -- Quote posting
  next(Quote_posted) := case
    Can_post_quote : TRUE;
    TRUE           : FALSE;
  esac;

  -- Pending_quote obligation
  next(Pending_quote) := next(Market_data);

  -- Update quotes when we post them
  next(Bid) := case
    Quote_posted & Mid = 0 : 0;
    Quote_posted          : Mid - 1;
    TRUE                  : Bid;
  esac;

  next(Ask) := case
    Quote_posted & Mid = 200 : 200;
    Quote_posted            : Mid + 1;
    TRUE                    : Ask;
  esac;

  -- Our Bid order state machine
  next(Bid_state) := case
    -- Cancel resolves immediately
    Bid_state = CANCEL_SENT : {FILLED, CANCELED};

    -- Posting a quote creates/refreshes an active order
    Quote_posted : ACTIVE;

    -- Active order may stay active or send cancel
    Bid_state = ACTIVE : {ACTIVE, CANCEL_SENT};

    -- Terminal states recycle
    Bid_state = FILLED   : NONE;
    Bid_state = CANCELED : NONE;

    TRUE : Bid_state;
  esac;

  -- Pending_cancel obligation: true exactly when cancel is in flight
  next(Pending_cancel) := (next(Bid_state) = CANCEL_SENT);

  -- Inventory update on fill
  next(Inv) := case
    (Bid_state = CANCEL_SENT) & (next(Bid_state) = FILLED) & (Inv < 10000) : Inv + 1;
    TRUE : Inv;
  esac;

-- Specs
LTLSPEC
  G (Pending_quote -> F Quote_posted);

LTLSPEC
  G (Pending_cancel -> F (Bid_state = FILLED | Bid_state = CANCELED));

LTLSPEC
  G (Quote_posted -> (Bid < Ask));
